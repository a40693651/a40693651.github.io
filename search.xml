<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>&lt;演算法教學&gt; Dijkstra單點源最短路演算法</title>
    <url>/%E6%BC%94%E7%AE%97%E6%B3%95%E6%95%99%E5%AD%B8/algorithm-Dijkstra/</url>
    <content><![CDATA[<p>Dijkstra演算法，戴克斯特拉演算法，用來解決單點源最短路問題的演算法。</p>
<p>講Dijkstra之前，我們要先了解鬆弛的概念，鬆弛就是兩個點之間，出現了一條更短路徑。舉例來講，a到b的距離是10，a到c到b的距離是8，因為出現了更短的路徑，因此我們說，c鬆弛了a到b。</p>
<p>Dijkstra的核心在於，我們在找最短路時，每次都選擇目前距離最近的點。因為其他點的距離都更遠，不可能去利用其他點來鬆弛這個點，所以這個點現在的距離保證會是他的最短距離。之後我們可以再利用這個保證是最短路徑的點，去試著鬆弛其他點。</p>
<p><img src="/演算法教學/algorithm-Dijkstra/Dijkstra.gif" alt=""></p>
<p>實作上，我們會利用priority_queue來達成，我們會把每個新被鬆弛出來的點，丟進去priority_queue裡面，並且把裡面最小的取出來，再用這個點去鬆弛其他點。</p>
<p>順帶一提，Dijkstra不能用在有負環的圖上，關於這個，我們會在下一篇的SPFA演算法中提到</p>
<h2 id="示範code"><a href="#示範code" class="headerlink" title="示範code:"></a>示範code:</h2><p>時間複雜度$O(NlogN)$<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">vector&lt; pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; gra[MAXN]; <span class="comment">// 圖</span></span><br><span class="line"><span class="type">int</span> dis[MAXN]; <span class="comment">// 記錄距離</span></span><br><span class="line"><span class="type">int</span> vis[MAXN]; <span class="comment">// 記錄是不是確定是最短路徑，並且鬆弛過別人了</span></span><br><span class="line"></span><br><span class="line">priority_queue&lt; pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; ,vector&lt; pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt;,greater&lt; pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; &gt; pq;</span><br><span class="line"><span class="comment">// greater 代表由小到大</span></span><br><span class="line"><span class="comment">// 裡面的儲存格式為&#123;dis[a],a&#125;，把點權放前面是因為priority_queue會優先以first項來排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果已經確定是最短路徑，後面得到的值一定不是最短的，直接丟掉換下一個</span></span><br><span class="line">    <span class="keyword">if</span>(vis[s])&#123; </span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(!pq.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="built_in">dijkstra</span>(pq.<span class="built_in">top</span>().S);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[s] = <span class="number">1</span>; <span class="comment">// 被拿來鬆弛其他人</span></span><br><span class="line"></span><br><span class="line">    pq.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(pair&lt;<span class="type">int</span>,<span class="type">int</span> &gt; i:gra[s])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[i.F]&gt;dis[s]+i.S)&#123; <span class="comment">// 鬆弛成功 // i.S表示邊權</span></span><br><span class="line">            dis[i.F] = dis[s]+i.S; <span class="comment">// 更新距離</span></span><br><span class="line">            pq.<span class="built_in">push</span>(&#123;dis[i.F],i.F&#125;); <span class="comment">// 有了更小的距離，因此丟進priority_queue中比較</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!pq.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="built_in">dijkstra</span>(pq.<span class="built_in">top</span>().S); <span class="comment">// 找下一個目前最近的點是誰</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>封面圖來源: <a href="https://www.pixiv.net/artworks/103214931">虹夏</a></p>
<hr>
]]></content>
      <categories>
        <category>演算法教學</category>
      </categories>
      <tags>
        <tag>圖論</tag>
        <tag>最短路</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;演算法教學&gt; 並查集資料結構</title>
    <url>/%E6%BC%94%E7%AE%97%E6%B3%95%E6%95%99%E5%AD%B8/algorithm-Disjoint-Set/</url>
    <content><![CDATA[<p>並查集(Disjoint-set)，用來處理物品是否同一群的資料結構，他可以做到合併、查詢集合的功能，所以稱為並查集。</p>
<p>我們透過紀錄每個點的父節點來達成，當兩個點被歸類到同一集合時，我們以這個集合的根最為父節點，我這裡稱為最終父節點。</p>
<p>查詢時，如果有兩個點的最終父節點相同，即代表他們在同個集合裡。</p>
<p>合併時，把其中一個集合的最終父節點，定為另一個集合的最終父節點，讓兩者最終父節點相同，即達成合併。</p>
<p>另外，合併有個優化的方法，稱為啟發式合併，在啟發式合併裡，我們選擇把比較小的集合併到比較大的集合中，這樣當這個比較小的集合要更新成新的父節點時，只要走更少的路。</p>
<p>這東西直接看code會更好懂一點。</p>
<h2 id="示範code"><a href="#示範code" class="headerlink" title="示範code"></a>示範code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> p[MAXN]; <span class="comment">// 節點的父節點</span></span><br><span class="line"><span class="type">int</span> s[MAXN]; <span class="comment">// 集合大小(size)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">//　初始化先把自己的父節點設為自己，並把集合大小設為1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		p[i] = i, s[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> v)</span></span>&#123; <span class="comment">// 查詢父節點</span></span><br><span class="line">	<span class="comment">// 看父節點是不是自己，不是就往上找父節點，直到最終父節點(父節點=自己)</span></span><br><span class="line">	<span class="keyword">return</span> p[v] == v ? v : p[v] = <span class="built_in">find</span>(p[v]); <span class="comment">// 順便把點的父節點更新成最終父節點</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uni</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123; <span class="comment">// 合併兩個集合</span></span><br><span class="line">	<span class="comment">// 讓a集合的最終父節點，變成b集合的最終父節點</span></span><br><span class="line">	<span class="comment">//  讓a集合並到b集合上</span></span><br><span class="line">	<span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">	p[pa] = pb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uni_inspire</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123; <span class="comment">// 啟發式合併版本</span></span><br><span class="line">	<span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">	<span class="keyword">if</span>(s[pa]&gt;s[pb]) <span class="built_in">swap</span>(pa,pb) <span class="comment">// 保持b團體更大</span></span><br><span class="line">	p[pa] = pb; <span class="comment">// 把小的a集合並到b集合上</span></span><br><span class="line">	s[pb] += s[pa]; <span class="comment">// 把size相加</span></span><br><span class="line">	s[pa] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>喔對，還有今天是虹夏的生日，都來祝他生日快樂</p>
<p><img src="/演算法教學/algorithm-Disjoint-Set/108535311.jpg" alt=""></p>
<p><a href="https://www.pixiv.net/artworks/108535311">【ぼっち・ざ・ろっく！】虹夏ちゃん誕生日おめでとうイラスト</a></p>
<hr>
]]></content>
      <categories>
        <category>演算法教學</category>
      </categories>
      <tags>
        <tag>圖論</tag>
        <tag>集合</tag>
        <tag>並查集</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;演算法教學&gt; Floyd-Warshall多點源最短路演算法</title>
    <url>/%E6%BC%94%E7%AE%97%E6%B3%95%E6%95%99%E5%AD%B8/algorithm-Floyd-Warshall/</url>
    <content><![CDATA[<p>Floyd-Warshall演算法，弗洛伊德演算法，用來解決多點源最短路問題的演算法。</p>
<p>相較於Dijkstra及SPFA只能找到對於一個起點的最短路徑，Floyd-Warshall可以用來找到圖上任意點對任意點的最短路徑。</p>
<p>Floyd-Warshall的概念相對起來好懂很多，就是幹下去就對了，用每一個點去鬆弛每一個點。直接用for迴圈枚舉就行，就直接看code吧</p>
<h2 id="示範code"><a href="#示範code" class="headerlink" title="示範code:"></a>示範code:</h2><p>時間複雜度$O(N^3)$<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> dp[MAXN]; <span class="comment">// 表示最短距離</span></span><br><span class="line"><span class="type">void</span> Floyd-<span class="built_in">Warshall</span>()&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &gt; dp[i][k] + dp[k][j])&#123;</span><br><span class="line">                    dp[i][j] = dp[i][k] + dp[k][j]; <span class="comment">// 當可以被鬆弛，則更新</span></span><br><span class="line">                &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>封面圖來源: <a href="https://www.pixiv.net/artworks/106493951">ん…ちょっと寂しかった……</a></p>
<hr>
]]></content>
      <categories>
        <category>演算法教學</category>
      </categories>
      <tags>
        <tag>圖論</tag>
        <tag>最短路</tag>
        <tag>Floyd-Warshall</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;演算法教學&gt; Kruskal最小生成樹演算法</title>
    <url>/%E6%BC%94%E7%AE%97%E6%B3%95%E6%95%99%E5%AD%B8/algorithm-Kruskal/</url>
    <content><![CDATA[<p>Kruskal，克魯斯克爾演算法，用貪心的方式，找出一張圖裡面，能連到所有邊的樹中，權值最小的，也就是<a href="https://zh.wikipedia.org/zh-tw/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91">最小生成樹(MST)</a></p>
<p><img src="/演算法教學/algorithm-Kruskal/MST.PNG" alt=""></p>
<p>首先，將所有邊排序一遍，依次把最小的邊與其連到的點加入最小生成樹的子圖中，等到所有點都被加入後，就能得到最小生成樹。要注意的是，在加入邊時，要避免子圖中出現環，不然就不會是樹了。</p>
<p>實作上，我們會利用並查集來檢查點是否已經在最小生成樹裡面，以及是否成環。</p>
<h2 id="示範code"><a href="#示範code" class="headerlink" title="示範code:"></a>示範code:</h2><p>(以上圖作為範例輸入輸出)<br>時間複雜度$O(MlogM)$<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pip pair<span class="string">&lt;int,pair&lt;int,int&gt;</span>&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;pip&gt; vec; <span class="comment">// 儲存邊</span></span><br><span class="line"><span class="type">int</span> p[MAXN]; <span class="comment">// 父節點</span></span><br><span class="line"><span class="type">int</span> s[MAXN]; <span class="comment">// 集合大小</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		p[i] = i, s[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> p[v] == v ? v : p[v] = <span class="built_in">find</span>(p[v]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uni</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">	p[pa] = pb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span>(pip i:vec)&#123;</span><br><span class="line">		<span class="type">int</span> a = i.S.F, b = i.S.S;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b)) <span class="keyword">continue</span>;<span class="comment">// 在同個集合下，也就是成環，試著加入重複點</span></span><br><span class="line">		<span class="built_in">uni</span>(a,b);</span><br><span class="line">		ans += i.F; <span class="comment">// 確定加入最小生成樹後，把權重加入答案</span></span><br><span class="line">	<span class="comment">// 當所有邊都跑完，就可以確定所有點都都被加進去</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">	<span class="type">int</span> a,b,w;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;</span><br><span class="line">	vec.<span class="built_in">push_back</span>(&#123; w, <span class="built_in">make_pair</span>(a, b) &#125;); <span class="comment">// 加入邊(權重放第一位，才能排序)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="built_in">kruskal</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input:</span><br><span class="line">5 6</span><br><span class="line">1 3 5</span><br><span class="line">1 4 1</span><br><span class="line">2 4 7122</span><br><span class="line">2 5 2</span><br><span class="line">3 5 5</span><br><span class="line">4 5 5</span><br></pre></td></tr></table></figure><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">output:</span><br><span class="line">13</span><br></pre></td></tr></table></figure></p>
<p>喔對，還有今天是虹夏的生日，都來祝他生日快樂</p>
<p><img src="/演算法教學/algorithm-Kruskal/108513584.jpg" alt=""></p>
<p>封面圖來源: <a href="https://www.pixiv.net/artworks/108513584">スーパー虹夏ちゃんまとめ</a></p>
<hr>
]]></content>
      <categories>
        <category>演算法教學</category>
      </categories>
      <tags>
        <tag>圖論</tag>
        <tag>最小生成樹</tag>
        <tag>Kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;演算法教學&gt; Prim最小生成樹演算法</title>
    <url>/%E6%BC%94%E7%AE%97%E6%B3%95%E6%95%99%E5%AD%B8/algorithm-Prim/</url>
    <content><![CDATA[<h1 id="臨時打字用"><a href="#臨時打字用" class="headerlink" title="臨時打字用"></a>臨時打字用</h1><p>Prim，普林演算法，用類似Dijkstra的方式，找出一張圖裡面，能連到所有邊的樹中，權值最小的，也就是<a href="https://zh.wikipedia.org/zh-tw/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91">最小生成樹(MST)</a></p>
<p><img src="/演算法教學/algorithm-Prim/MST.PNG" alt=""></p>
<p>首先，類似於Dijkstra的作法，先從圖中挑一個點，把邊都丟進priority_queue中，找出目前的最小邊。</p>
<p>因為我們保證每個點都會被用到所以要連接到一個點，可以從其他任意點過來，也就是可以挑這個點的任意邊。那自然我們會挑最小的那條邊。</p>
<p>接著我們看這個邊連到誰，把邊丟進priority_queue裡面，繼續挑最小的往下做。如果遇到挑最小邊可能成環的狀況，就不要挑這條邊。</p>
<p>因為挑了意味著必須把另一條相對的邊去掉，但是其他會成環的邊，一定是在最小生成樹內，也就是priority_queue篩選出來比這個邊更小的邊，才會形成環，所以這個替換必然會造成權值更大，所以不挑。</p>
<p>ex:<br><img src="/演算法教學/algorithm-Prim/Prim.PNG" alt=""><br>當我們在挑下一條邊時，最小邊是3，但是他會連回到A點形成環。如果要把這個3的最小邊接起來，勢必要去掉1或2這兩條邊，那這個替換顯然不好，所以我們改挑下一條長度4的邊</p>
<h2 id="示範code"><a href="#示範code" class="headerlink" title="示範code:"></a>示範code:</h2><p>(以上圖作為範例輸入輸出)<br>時間複雜度$O(NlogN)$<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;pii&gt; vec[MAXN];</span><br><span class="line"><span class="type">int</span> vis[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Prim</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq; <span class="comment">// 用來排列目前最小邊</span></span><br><span class="line">	pq.<span class="built_in">push</span>(<span class="number">0</span>,<span class="number">1</span>) <span class="comment">// 放入一個點當源點</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line"></span><br><span class="line">		pii u = pq.<span class="built_in">top</span>();</span><br><span class="line">		pq.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(vis[u.S]) <span class="keyword">continue</span>; <span class="comment">//這個點已經被挑過</span></span><br><span class="line">		vis[u.S] = <span class="number">1</span>;</span><br><span class="line">		ans += u.F <span class="comment">// 加入權值</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(pii i:vec[u])&#123;</span><br><span class="line">			<span class="type">int</span> point = i.F, w = i.S;</span><br><span class="line">			pq.<span class="built_in">push</span>(&#123;w,point&#125;) <span class="comment">// 權值放前面，來能用來排序</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">	<span class="type">int</span> a,b,w;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b,w;</span><br><span class="line">	vec[a].<span class="built_in">push_back</span>(&#123;b,w&#125;);</span><br><span class="line">	vec[b].<span class="built_in">push_back</span>(&#123;a,w&#125;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="built_in">Prim</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input:</span><br><span class="line">5 6</span><br><span class="line">1 3 5</span><br><span class="line">1 4 1</span><br><span class="line">2 4 7122</span><br><span class="line">2 5 2</span><br><span class="line">3 5 5</span><br><span class="line">4 5 5</span><br></pre></td></tr></table></figure><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">output:</span><br><span class="line">13</span><br></pre></td></tr></table></figure></p>
<p>喔對，還有今天是虹夏的生日，都來祝他生日快樂</p>
<p><img src="/演算法教學/algorithm-Prim/1662836880839430145.jpg" alt=""></p>
<p>封面圖來源: <a href="https://twitter.com/KKito55/status/1662836880839430145">伊地知虹夏生誕祭2023</a></p>
<hr>
]]></content>
      <categories>
        <category>演算法教學</category>
      </categories>
      <tags>
        <tag>圖論</tag>
        <tag>最小生成樹</tag>
        <tag>Prim</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;演算法教學&gt; SPFA單點源最短路演算法</title>
    <url>/%E6%BC%94%E7%AE%97%E6%B3%95%E6%95%99%E5%AD%B8/algorithm-SPFA/</url>
    <content><![CDATA[<p>SPFA(Shortest Path Faster Algorithm)，最短路徑快速算法，帶有queue優化的Bellman-Ford算法。(因為SPFA比較常用，就直接講SPFA，Bellman-Ford就請有興趣的人去再去研究)</p>
<p>這個演算法通常用來解決圖上可能有負環的情況，也就是我們上一篇提到，Dijkstra演算法無法解決的狀況。讓我們先來看看，有負環的情況下，會發生甚麼事?</p>
<p><img src="/演算法教學/algorithm-SPFA/negative-loop.gif" alt=""></p>
<p>可以發現他會進入一個無限迴圈，一直在負環裡面跑，讓負環上的點的距離值不斷被更新、變小。</p>
<p>也就是說，存在負環的狀況下，我們不可能找到最短路徑，因為路徑會不斷變短。所以我們要使用SPFA來解決這個問題，判斷負環是否存在。</p>
<p>判斷負環是否存在的關鍵，在於更新次數。首先讓我們想想一個點最多被更新幾次?顯然是n-1次，因為只能被其他點各鬆弛一次，當一直被重複更新時，更新次數就會超過n-1，也就是出現了負環，SPFA也就是針對此判斷。</p>
<p>SPFA與Bellman-Ford差別最大的是在於queue的優化，Bellman-Ford會直接不管三七二十一的，直接跑n-1次。這裡則利用類似BFS的方式來做優化，讓他不用跑滿n-1次。</p>
<p>SPFA很像BFS，就是從起點開始，一直往下跑，看下面的點能不能被當前的點更新到，最大的差別是，SPFA是可以往回跑到重複的點的，也就是可以在後面更新出更短的路徑時，跑回去更新前面的點，就因此解決了BFS只能解決邊權唯一圖形的狀況。</p>
<p>跑的過程中，如果可以更新，就記錄更新次數加一，如果更新次數超過了n-1，代表重複更新，有負環存在。如果沒有超過的話，更新完的值也是更新到不能再更新了。</p>
<p>其中，我們在queue的使用上，會用inque來記錄這個點是否在queue裡面，如果一個點已經在queue裡面，代表他即將被用來更新其他點，這時候就算被更新一個新的距離，也不必再把他丟進去一次，只要把distance陣列中的值改掉，在更新的時候就會使用最小的值。</p>
<p>ex: 有a-&gt;c,距離10的路，b-&gt;c距離5的路，假設dis[a]=3,dis[b]=5，dis[c]先被更新成dis[a]+10=13丟進queue裡面，接著dis[c]又被更新成dis[b]+5=10，這時候就不用再丟進queue一次，因為從queue拿出來的時候，會以當下的dis[c]來鬆弛其他點，也就是dis[c]=10。</p>
<h2 id="示範code"><a href="#示範code" class="headerlink" title="示範code:"></a>示範code:</h2><p>時間複雜度$O(NM)$<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> dis[MAXN]; <span class="comment">// 距離</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que; </span><br><span class="line"><span class="type">int</span> inque[MAXN]; <span class="comment">// 記錄這個點是不是在queue裡面</span></span><br><span class="line"><span class="type">int</span> num[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> n)</span></span>&#123; <span class="comment">// 以v當作起點，有n個點</span></span><br><span class="line">	dis[v] = <span class="number">0</span>;</span><br><span class="line">	que.<span class="built_in">push</span>(v);</span><br><span class="line">	inque[v] = <span class="number">1</span>; <span class="comment">// 點v進入queue</span></span><br><span class="line">	<span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> u = que.<span class="built_in">front</span>();</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">		inque[u] = <span class="number">0</span>; <span class="comment">// 點v離開queue</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(pii i:vec[u])&#123;</span><br><span class="line">			<span class="keyword">if</span>(dis[i.F] &gt; dis[u]+i.S)&#123; <span class="comment">// i.S 表示邊權</span></span><br><span class="line">				num[i.F]++;</span><br><span class="line">				<span class="keyword">if</span>(num[i.F] &gt; n<span class="number">-1</span>)&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果更新次數大於n-1，代表重複更新，有負環存在</span></span><br><span class="line">				&#125;</span><br><span class="line">				dis[i.F] = dis[u]+i.S;</span><br><span class="line">				<span class="keyword">if</span>(inque[i.F]==<span class="number">0</span>)&#123;</span><br><span class="line">					que.<span class="built_in">push</span>(i.F);</span><br><span class="line">					inque[i.F]=<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>封面圖來源: <a href="https://www.pixiv.net/artworks/104987258">伊地知 虹夏</a></p>
<hr>
]]></content>
      <categories>
        <category>演算法教學</category>
      </categories>
      <tags>
        <tag>圖論 - 最短路 - SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;演算法教學&gt; 拓樸排序演算法</title>
    <url>/%E6%BC%94%E7%AE%97%E6%B3%95%E6%95%99%E5%AD%B8/algorithm-Topological-Sorting/</url>
    <content><![CDATA[<p>拓樸排序(Topological Sorting)用於<a href="https://zh.wikipedia.org/zh-tw/%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE">有向無環圖(DAG)</a>上，可以排出一個節點順序，保證每個節點被經過時，前面指向他的節點都已經被經過。</p>
<p>可以用於任務有前置條件時，對任務的排序，或是最長路徑的計算。</p>
<p>示例圖:<br>(黑字:點編號, 紅字:執行順序)</p>
<p><img src="/演算法教學/algorithm-Topological-Sorting/task_sort.PNG" alt=""></p>
<p>拓樸排序的核心在於，不斷找出入度為0的點，也就是沒有任何前置任務，可以直接執行的任務。</p>
<p>一開始，我們先找到初始入度為0的點，並把他加入我們的工作執行序列裡。接著，當我們從工作執行序列裡，將其取出並執行完成後，把它指向的節點，入度全部減一，代表前置任務被完成了一項。如果這些節點有入度成為0的點，代表他也可以直接執行，所以加入工作執行序列中，就這樣一路做到底，就完成了拓樸排序了。</p>
<h2 id="示範code"><a href="#示範code" class="headerlink" title="示範code:"></a>示範code:</h2><p>時間複雜度$O(N)$<br>(以上圖為例)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> rd[MAXN]; <span class="comment">// 入度</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec[MAXN]; <span class="comment">// 存圖</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_func</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="comment">// 執行函式</span></span><br><span class="line">	cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topo</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; que; <span class="comment">// 工作序列</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(rd[i]==<span class="number">0</span>) que.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u = que.<span class="built_in">front</span>();</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">do_func</span>(u); <span class="comment">// 執行這個任務</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i:vec[u])&#123;</span><br><span class="line">			rd[i]--; <span class="comment">// 因為前一個任務被執行完，所以入度減一</span></span><br><span class="line">			<span class="keyword">if</span>(rd[i]==<span class="number">0</span>) que.<span class="built_in">push</span>(i); <span class="comment">// 沒有前置序列，加入最長路</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m; <span class="comment">// 點數,邊數</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> a,b;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		vec[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">		rd[b]++; <span class="comment">// 被指向，所以b的入度+1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">topo</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input:</span><br><span class="line">5 5</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">output:</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>喔對，還有今天是虹夏的生日，都來祝他生日快樂</p>
<p><img src="/演算法教學/algorithm-Topological-Sorting/108530112.jpg" alt=""></p>
<p><a href="https://www.pixiv.net/artworks/108530112">虹夏ちゃん誕生日おめでとう🎉🎉🎉【2023】</a></p>
<hr>
]]></content>
      <categories>
        <category>演算法教學</category>
      </categories>
      <tags>
        <tag>圖論</tag>
        <tag>DAG</tag>
        <tag>拓樸排序</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;洛谷&gt; P1351 [NOIP2014 提高組] 聯合權值</title>
    <url>/%E6%B4%9B%E8%B0%B7/luogu-P1351/</url>
    <content><![CDATA[<h2 id="題目-P1351-NOIP2014-提高組-聯合權值"><a href="#題目-P1351-NOIP2014-提高組-聯合權值" class="headerlink" title="題目: P1351 [NOIP2014 提高組] 聯合權值"></a>題目: <a href="https://www.luogu.com.cn/problem/P3387">P1351 [NOIP2014 提高組] 聯合權值</a></h2><p>原本看這題的tag，以為會是難題，結果其實滿水的</p>
<p>首先，n個點n-1個邊，顯然是一棵樹，接著他要求距離為2的點對，那顯然是中間跨過一個點，所以我們只要找出每個點作為中間點的情況，然後把他們兩兩組合就好了。</p>
<p>另外，最大值只要把中間點連到的點，找出最大的兩個點相乘，就可以得到這個中間點能創造的最大權值，把每個點比一遍就好。</p>
<p>要注意的是，他的最大值不要求取模，我就被這卡了好一陣子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">10007</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; tree[MAXN];</span><br><span class="line"><span class="type">int</span> w[MAXN];</span><br><span class="line"><span class="type">int</span> child[MAXN];</span><br><span class="line"><span class="type">int</span> vis[MAXN];</span><br><span class="line"><span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  vis[v] = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> mx_1 = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> mx_2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i : tree[v]) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (w[i] &gt; mx_1)</span><br><span class="line">      mx_2 = mx_1, mx_1 = w[i];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (w[i] &gt; mx_2)</span><br><span class="line">      mx_2 = w[i];</span><br><span class="line">      </span><br><span class="line">    ans = (ans + (child[v] * w[i]) % mod) % mod;</span><br><span class="line">    child[v] = (child[v] + w[i]) % mod;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">      <span class="built_in">DFS</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mx = <span class="built_in">max</span>(mx, mx_1 * mx_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    tree[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    tree[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    cin &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DFS</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; mx &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (ans * <span class="number">2</span>) % mod &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>封面圖來源: <a href="https://www.pixiv.net/artworks/104327420">虹夏ちゃん</a></p>
<hr>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>圖論</tag>
        <tag>DFS</tag>
        <tag>普及+/提高</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;洛谷&gt; P1541 [NOIP2010 提高組] 烏龜棋</title>
    <url>/%E6%B4%9B%E8%B0%B7/luogu-P1541/</url>
    <content><![CDATA[<h2 id="題目-P1541-NOIP2010-提高組-烏龜棋"><a href="#題目-P1541-NOIP2010-提高組-烏龜棋" class="headerlink" title="題目: P1541 [NOIP2010 提高組] 烏龜棋"></a>題目: <a href="https://www.luogu.com.cn/problem/P1541">P1541 [NOIP2010 提高組] 烏龜棋</a></h2><p>這題很顯然是個標準的DP，我一開始的想法是，直接開一個5維的陣列$dp[格子數][卡片1][卡片2][卡片3][卡片4]$，枚舉格子數去做線性dp，但這樣會直接RE。所以勢必要把<strong>格子數</strong>去掉，陣列才可能放得下，後來發現格子數其實就是使用的卡片數量乘以權值加總，所以就可以直接丟掉格子數，改成枚舉4種卡片的數量。</p>
<p>轉移式變成以下:<br>使用卡片1:</p>
<p>$dp[卡片1][卡片2][卡片3][卡片4] = dp[卡片1 - 1][卡片2][卡片3][卡片4] + arr[step]$</p>
<p>arr是儲存格子權值的陣列，step是當前的位置，也就是卡片數量乘以權值加總。<br>其他以此類推…</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">355</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">45</span>; <span class="comment">// 40^4 = 2.5e6 是可以接受的空間複雜度</span></span><br><span class="line"><span class="type">int</span> arr[MAXN]; <span class="comment">// 儲存格子權值</span></span><br><span class="line"><span class="type">int</span> card[<span class="number">5</span>]; <span class="comment">// 儲存卡片數量</span></span><br><span class="line"><span class="type">int</span> dp[MAXM][MAXM][MAXM][MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    cin&gt;&gt;arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    card[a]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = arr[<span class="number">1</span>]; <span class="comment">// 初始站在起點，把起點的值加進來</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=card[<span class="number">1</span>];i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=card[<span class="number">2</span>];j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=card[<span class="number">3</span>];k++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;=card[<span class="number">4</span>];l++)&#123;</span><br><span class="line">                <span class="type">int</span> step = <span class="number">1</span> + i*<span class="number">1</span> + j*<span class="number">2</span> + k*<span class="number">3</span> + l*<span class="number">4</span>; <span class="comment">// 起始點是1，所以用完當下這些卡片會到的格子要+1</span></span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">                    dp[i][j][k][l] = <span class="built_in">max</span>(dp[i][j][k][l], dp[i<span class="number">-1</span>][j][k][l] + arr[step]);</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>)</span><br><span class="line">                    dp[i][j][k][l] = <span class="built_in">max</span>(dp[i][j][k][l], dp[i][j<span class="number">-1</span>][k][l] + arr[step]);</span><br><span class="line">                <span class="keyword">if</span>(k&gt;<span class="number">0</span>)</span><br><span class="line">                    dp[i][j][k][l] = <span class="built_in">max</span>(dp[i][j][k][l], dp[i][j][k<span class="number">-1</span>][l] + arr[step]);</span><br><span class="line">                <span class="keyword">if</span>(l&gt;<span class="number">0</span>)</span><br><span class="line">                    dp[i][j][k][l] = <span class="built_in">max</span>(dp[i][j][k][l], dp[i][j][k][l<span class="number">-1</span>] + arr[step]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;dp[ card[<span class="number">1</span>] ][ card[<span class="number">2</span>] ][ card[<span class="number">3</span>] ][ card[<span class="number">4</span>] ]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>封面圖來源: <a href="https://www.pixiv.net/artworks/107025668">イメチェン꒰ঌ ( ˶’ᵕ’˶) ໒꒱｢に、似合うかな….｣</a></p>
<hr>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;洛谷&gt; P2014 [CTSC1997] 選課</title>
    <url>/%E6%B4%9B%E8%B0%B7/luogu-P2014/</url>
    <content><![CDATA[<h2 id="題目-P2014-CTSC1997-選課"><a href="#題目-P2014-CTSC1997-選課" class="headerlink" title="題目: P2014 [CTSC1997] 選課"></a>題目: <a href="https://www.luogu.com.cn/problem/P2014">P2014 [CTSC1997] 選課</a></h2><p>這種選課的題目，我第一個想法是DAG，不過後來想了想，用DAG來求最大值好像不太好做。所以就改成我們常常用來求最大值的方法—-DP</p>
<p>這題要進行DP首先要解決的問題是，他有多的入度為0的點，有就是說起點有好幾個，這樣是不能直接做DP的，所以這裡要用到一個技巧，我們設置一個超級原點(編號0)，連到那些入度為0的點，再去做後續的DP，就會好做很多。</p>
<p>並且當我們把超級原點加進去之後，會發現整個圖形變成了一棵樹，這時候就很明顯的要使用樹DP了。</p>
<p>至於轉移式的處理，這裡的轉移式不是單純的一個式子，而更像是背包DP那樣的轉移。</p>
<p>核心概念是，我們先把大問題簡化，假設有棵樹，根結點底下有x個子樹，我們已知關於這個子樹的所有數據，現在我們要做的是，決定從各個子樹裡面，要各自挑多少堂課，才會組成最大值。這裡就像是背包問題，只是從挑選要或不要，變成挑選各要拿幾個。</p>
<p>所以我們會試著找，這棵樹裡面我們總共要拿w堂課時，也就對應到背包問題的重量。然後枚舉子樹裡面要拿幾堂課(j)可以得到最大值，這樣就算是完成這個背包問題裡面的第一個物品(子樹)。</p>
<p>可以寫出轉移式:</p>
<script type="math/tex; mode=display">
    dp[v][w] = max(dp[v][w],dp[v][w-j]+dp[sub][j])</script><p>接著枚舉總共拿幾堂課的不同情況(不同w)，也就對應到背包問題的枚舉重量，得到挑到目前的子樹時，不同課數下的最大值。</p>
<p>然後換到下一個物品，繼續做同樣的枚舉，最後就可以得到，這棵樹中，拿多少堂課的最大值。</p>
<p>知道轉移式之後，我們只要照一般樹DP的作法，DFS到底部，再遞迴回來，就可以在我們的超級原點，得到整個圖來講，拿多少堂課可以得到的最大值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">305</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; tree[MAXN]; <span class="comment">// 樹</span></span><br><span class="line"><span class="type">int</span> score[MAXN]; <span class="comment">// 紀錄這個點的分數</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dp[MAXN][MAXN]; <span class="comment">// 點編號,選的課數</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tree[v].<span class="built_in">empty</span>()) <span class="keyword">return</span>; <span class="comment">// 到葉節點直接return</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> sub:tree[v])&#123; <span class="comment">// 枚舉子樹(物品)</span></span><br><span class="line">		<span class="built_in">DFS</span>(sub); <span class="comment">// 樹DP的基本作法，DFS下去</span></span><br><span class="line">        <span class="comment">// 接著做類似背包的轉移</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=<span class="number">1</span>;i--)&#123; <span class="comment">// 枚舉要拿幾堂課(必定包含自己，所以至少1)</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i<span class="number">-1</span>;j++)&#123; <span class="comment">// 枚舉這個子樹裡，要拿多少課最好</span></span><br><span class="line">				dp[v][i] = <span class="built_in">max</span>(dp[v][i], dp[v][i-j] + dp[sub][j]); </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">	<span class="type">int</span> k,s;</span><br><span class="line">	cin&gt;&gt;k&gt;&gt;s;</span><br><span class="line">	score[i] = s;</span><br><span class="line">	dp[i][<span class="number">1</span>] = s; <span class="comment">// 初始化，在點i當根節點的時候，只拿一個必定是自己</span></span><br><span class="line">	tree[k].<span class="built_in">push_back</span>(i); </span><br><span class="line">    <span class="comment">// 在這裡有k=0是沒有入度的情況</span></span><br><span class="line">    <span class="comment">// 所以我們直接把超級原點編號設0，就可以不用特殊處理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m++; <span class="comment">// 因為會多選到一個超級原點，所以要多加一個課程量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">DFS</span>(<span class="number">0</span>); <span class="comment">// 從超級原點開始</span></span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">	ans = <span class="built_in">max</span>(ans,dp[<span class="number">0</span>][i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>封面圖來源: <a href="https://www.pixiv.net/artworks/108353513">早めの夏!!暑すぎます☀️</a></p>
<hr>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>圖論</tag>
        <tag>普及+/提高</tag>
        <tag>DP</tag>
        <tag>樹</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;洛谷&gt; P2047 [NOI2007] 社交網路</title>
    <url>/%E6%B4%9B%E8%B0%B7/luogu-P2047/</url>
    <content><![CDATA[<h2 id="題目-P2047-NOI2007-社交網路"><a href="#題目-P2047-NOI2007-社交網路" class="headerlink" title="題目: P2047 [NOI2007] 社交網路"></a>題目: <a href="https://www.luogu.com.cn/problem/P2047">P2047 [NOI2007] 社交網路</a></h2><p>首先，題目要我們求出，一個點的重要性，而這個重要性會從每條經過他的最短路徑加總而來，所以可以推測這題大概是多點源最短路。另外$N&lt;=100$，所以Floyd Warshall演算法的$N^3$時間複雜度是可以接受的。所以我們利用Floyd Warshall演算法來處理。</p>
<p>接著，從題目可以看出，我們需要兩個東西:</p>
<ol>
<li>i到j的最短路有幾個</li>
<li>i到j的最短路中，經過k的有幾個</li>
</ol>
<p>先假設i到j的最短路數量是path[i][j]</p>
<p>第一項可以透過Floyd Warshall進行更新時處理，當出現更短的路徑時，代表path[i][j]刷新。因為Floyd Warshall是在經過第k個點被鬆弛時更新，也就是會在k點的兩側各挑一條最短路，因此新的最短路數量就是path[i][k] * path[k]<a href="就基本的乘法原理">j</a>。</p>
<p>第二項，要確定某條最短路有沒有經過k，只要判斷path[i][k] + path[k][j]會不會等於path[i][j]，如果等於的話就一定是，大於顯然不是，也不會有小於的狀況，不然就出現更短的路徑了。而path[i][k] * path[k][j]就會是經過k的最短路數量。</p>
<p>最後在把兩者相除，即個得到k對於一組(i,j)的重要性，接著遍歷一遍即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">105</span>;</span><br><span class="line">vector&lt;pii&gt; vec[MAXN]; <span class="comment">// 圖</span></span><br><span class="line"><span class="type">int</span> dp[MAXN][MAXN]; <span class="comment">// 最短距離</span></span><br><span class="line"><span class="type">double</span> path[MAXN][MAXN]; <span class="comment">// 最短路徑數量</span></span><br><span class="line"><span class="type">double</span> imp[MAXN]; <span class="comment">// 重要性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">	dp[i][j] = <span class="number">10000000005</span>;</span><br><span class="line">	path[i][j]=<span class="number">1</span>; <span class="comment">// 這樣更新的時候才有值，不然就變成0*0</span></span><br><span class="line">	<span class="keyword">if</span>(i==j) dp[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">	imp[k] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">	<span class="type">int</span> a,b,w;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;</span><br><span class="line">	vec[a].<span class="built_in">push_back</span>(&#123;b,w&#125;);</span><br><span class="line">	dp[a][b] = w;</span><br><span class="line">	vec[b].<span class="built_in">push_back</span>(&#123;a,w&#125;);</span><br><span class="line">	dp[b][a] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==k || j==k) <span class="keyword">continue</span>; <span class="comment">// 避免出現用自己來更新，結果重複累加的狀況</span></span><br><span class="line">			<span class="keyword">if</span>(dp[i][j] &gt; dp[i][k] + dp[k][j])&#123;</span><br><span class="line">				dp[i][j] = dp[i][k] + dp[k][j];</span><br><span class="line">				path[i][j] = path[i][k] * path[k][j]; <span class="comment">// 因為是新的最短距離，所以重新給path一個值</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(dp[i][j] == dp[i][k] + dp[k][j])&#123;</span><br><span class="line">				path[i][j] += path[i][k] * path[k][j]; <span class="comment">// 因為是同個最距離，所以不重新給，用累加</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==k || j==k) <span class="keyword">continue</span>; <span class="comment">// 避免出現把自己更新自己記入的情況</span></span><br><span class="line">			<span class="keyword">if</span>(dp[i][k] + dp[k][j] == dp[i][j])&#123; <span class="comment">// 表示此最短路必定經k</span></span><br><span class="line">				<span class="keyword">if</span>(path[i][j]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">				imp[k] += path[i][k] * path[k][j] / path[i][j];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">3</span>)&lt;&lt;imp[k]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>封面圖來源: <a href="https://www.pixiv.net/artworks/108188130">メイド虹歌ちゃん</a></p>
<hr>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>圖論 - 最短路 - Floyd-Warshall - 普及+/提高</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;洛谷&gt; P2827 [NOIP2016 提高組] 蚯蚓</title>
    <url>/%E6%B4%9B%E8%B0%B7/luogu-P2827/</url>
    <content><![CDATA[<h2 id="題目-P2827-NOIP2016-提高組-蚯蚓"><a href="#題目-P2827-NOIP2016-提高組-蚯蚓" class="headerlink" title="題目: P2827 [NOIP2016 提高組] 蚯蚓"></a>題目: <a href="https://www.luogu.com.cn/problem/P2827">P2827 [NOIP2016 提高組] 蚯蚓</a></h2><h2 id="90分解"><a href="#90分解" class="headerlink" title="90分解:"></a>90分解:</h2><p>看到這個題目，我第一個想到的就是用<strong>priority_queue</strong>來維護，一個一個找出最長的蟲子，並做操作。</p>
<p>其中，需要處理的是，每隻蟲子會成長的問題。因為不可能把資結裡面的所有蟲子都加上成長量，因此我們換個思路。因為在資結裡的資料，重點是要比大小，因此只要能讓他的大小順序保持住就好。那我們就不對資料結構裡面的所有蟲加上成長量，反過來把新加入的蟲(切出來的)減去成長量，他們之間的相對值就能維持住。另外開一個變數來記錄總成長量，當我們需要求蟲的長度時，再把成長量加回去就可以得到值了。</p>
<p>這個方法的複雜度是$O(MlogN)$，我本來預期會過，不過出題者好像把這個複雜度卡掉了。如果壓常很強的話，搞不好可以透過這個方法AC?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line"><span class="type">int</span> n,m,q,t;</span><br><span class="line"><span class="type">double</span> u,v;</span><br><span class="line"><span class="type">double</span> p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios_base::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;q&gt;&gt;u&gt;&gt;v&gt;&gt;t;</span><br><span class="line">	<span class="type">int</span> num = n; <span class="comment">// 用來記錄目前有幾隻蟲</span></span><br><span class="line">	p = u/v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">double</span> temp;</span><br><span class="line">		cin&gt;&gt;temp;</span><br><span class="line">		pq.<span class="built_in">push</span>(temp); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> len_add = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> longest = pq.<span class="built_in">top</span>() + len_add; </span><br><span class="line">		pq.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(i%t==<span class="number">0</span>)&#123;</span><br><span class="line">			cout&lt;&lt;longest&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		num--;</span><br><span class="line">		len_add += q; <span class="comment">// 總成長量為 m*q</span></span><br><span class="line">		<span class="type">int</span> a = <span class="built_in">int</span>(longest * p);</span><br><span class="line">		<span class="type">int</span> b = longest - a;</span><br><span class="line">		pq.<span class="built_in">push</span>(a - len_add ); <span class="comment">// 減去總成長量，等於前面這一段時間的成長量都沒有吃掉</span></span><br><span class="line">		pq.<span class="built_in">push</span>(b - len_add);</span><br><span class="line">		num += <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i%t==<span class="number">0</span>)</span><br><span class="line">			cout&lt;&lt;pq.<span class="built_in">top</span>() + len_add&lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">// 因為有減去，所以拿出來的時候，加回來</span></span><br><span class="line">		pq.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="100分解"><a href="#100分解" class="headerlink" title="100分解:"></a>100分解:</h2><p>這個方法是利用單調性來維護，就可以去掉$logN$的複雜度，把剩下的十分拿下。</p>
<p>不過這是我看題解思路寫的，我自己真的沒有觀察出他有單調性。</p>
<p>首先，要觀察出一件事，<strong>先被切出來的蟲，一定比後被切出來的蟲長</strong><br>假設目前最大的兩隻蟲為$a,b$，$a&gt;b$<br>過一秒後，$a$被切成$pa,(1-p)a$，$b$成長為$b+q$<br>再過一秒，$a$的兩條蟲成長為$pa+q,(1-p)a+q$，$b$被切成$pb+pq,(1-p)b+(1-p)q$<br>因為$a&gt;b$，$0 &gt; p &gt; 1$，所以$pa+q &gt; pb+pq$，$(1-p)a+q &gt; (1-p)b+(1-p)q$<br>可以發現切出來的蟲中，較長蟲一定比後面切出的較長蟲更長，較短蟲一定比後面切出的較短蟲更長<br>接下來兩者的成長都是同時發生，所以相對大小不變<br>發現他的單調性，再把它分成另外兩堆，就可以不用priority_queue來維護了<br>找最長的蟲時，只要從這兩堆，跟原本還沒被切過的那堆(3堆)中，挑出來最大的就行了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; non_dq; <span class="comment">// 沒被切的蟲</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; dq_min; <span class="comment">// 切出來較短的蟲</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; dq_max; <span class="comment">// 切出來較長的蟲</span></span><br><span class="line"><span class="type">int</span> n,m,q,t;</span><br><span class="line"><span class="type">double</span> u,v;</span><br><span class="line"><span class="type">double</span> p;</span><br><span class="line"><span class="type">int</span> len_add = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_longest</span><span class="params">()</span></span>&#123; <span class="comment">// 從3堆中找最大值得函式，我寫的比較醜一點</span></span><br><span class="line">	<span class="type">int</span> longest;</span><br><span class="line">	<span class="keyword">if</span>(dq_max.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="keyword">if</span>(dq_min.<span class="built_in">empty</span>())</span><br><span class="line">			longest = non_dq.<span class="built_in">back</span>() + len_add,non_dq.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(non_dq.<span class="built_in">empty</span>())</span><br><span class="line">			longest = dq_min.<span class="built_in">back</span>() + len_add,dq_min.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(non_dq.<span class="built_in">back</span>() &gt;= dq_min.<span class="built_in">back</span>())</span><br><span class="line">				longest = non_dq.<span class="built_in">back</span>() + len_add,non_dq.<span class="built_in">pop_back</span>();</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				longest = dq_min.<span class="built_in">back</span>() + len_add,dq_min.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(dq_min.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="keyword">if</span>(dq_max.<span class="built_in">empty</span>())</span><br><span class="line">			longest = non_dq.<span class="built_in">back</span>() + len_add,non_dq.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(non_dq.<span class="built_in">empty</span>())</span><br><span class="line">			longest = dq_max.<span class="built_in">back</span>() + len_add,dq_max.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(non_dq.<span class="built_in">back</span>() &gt;= dq_max.<span class="built_in">back</span>())</span><br><span class="line">				longest = non_dq.<span class="built_in">back</span>() + len_add,non_dq.<span class="built_in">pop_back</span>();</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				longest = dq_max.<span class="built_in">back</span>() + len_add,dq_max.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(non_dq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="keyword">if</span>(dq_max.<span class="built_in">empty</span>())</span><br><span class="line">			longest = dq_min.<span class="built_in">back</span>() + len_add,dq_min.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(dq_min.<span class="built_in">empty</span>())</span><br><span class="line">			longest = dq_max.<span class="built_in">back</span>() + len_add,dq_max.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(dq_max.<span class="built_in">back</span>() &gt;= dq_min.<span class="built_in">back</span>())</span><br><span class="line">				longest = dq_max.<span class="built_in">back</span>() + len_add,dq_max.<span class="built_in">pop_back</span>();</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				longest = dq_min.<span class="built_in">back</span>() + len_add,dq_min.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(dq_min.<span class="built_in">back</span>() &gt;= dq_max.<span class="built_in">back</span>() &amp;&amp; dq_min.<span class="built_in">back</span>() &gt;= non_dq.<span class="built_in">back</span>())</span><br><span class="line">			longest = dq_min.<span class="built_in">back</span>() + len_add,dq_min.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(dq_max.<span class="built_in">back</span>() &gt;= dq_min.<span class="built_in">back</span>() &amp;&amp; dq_max.<span class="built_in">back</span>() &gt;= non_dq.<span class="built_in">back</span>())</span><br><span class="line">			longest = dq_max.<span class="built_in">back</span>() + len_add,dq_max.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			longest = non_dq.<span class="built_in">back</span>() + len_add,non_dq.<span class="built_in">pop_back</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios_base::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;q&gt;&gt;u&gt;&gt;v&gt;&gt;t;</span><br><span class="line">	<span class="type">int</span> num = n;</span><br><span class="line">	p = u/v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">double</span> temp;</span><br><span class="line">		cin&gt;&gt;temp;</span><br><span class="line">		non_dq.<span class="built_in">push_back</span>(temp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(non_dq.<span class="built_in">begin</span>(), non_dq.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> longest = <span class="built_in">find_longest</span>();</span><br><span class="line">		<span class="keyword">if</span>(i%t==<span class="number">0</span>)&#123;</span><br><span class="line">			cout&lt;&lt;longest&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		num--;</span><br><span class="line">		len_add += q;</span><br><span class="line">		<span class="type">int</span> a = <span class="built_in">int</span>(longest * p);</span><br><span class="line">		<span class="type">int</span> b = longest - a;</span><br><span class="line">		<span class="keyword">if</span>(a&lt;b) <span class="built_in">swap</span>(a,b); <span class="comment">// 保持a是比較長的那隻</span></span><br><span class="line">		dq_max.<span class="built_in">push_front</span>(a - len_add); <span class="comment">// 把較長的蟲，跟較短的蟲分開維護</span></span><br><span class="line">		dq_min.<span class="built_in">push_front</span>(b - len_add);</span><br><span class="line">		num += <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;i++)&#123;</span><br><span class="line">		<span class="type">int</span> longest = <span class="built_in">find_longest</span>();</span><br><span class="line">		<span class="keyword">if</span>(i%t==<span class="number">0</span>)</span><br><span class="line">			cout&lt;&lt;longest&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>封面圖來源: <a href="https://www.pixiv.net/artworks/106276835">虹夏ちゃん✨</a></p>
<hr>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>單調</tag>
        <tag>priority_queue</tag>
        <tag>提高+/省選-</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;洛谷&gt; P3387 【模板】縮點</title>
    <url>/%E6%B4%9B%E8%B0%B7/luogu-P3387/</url>
    <content><![CDATA[<h2 id="題目-P3387-【模板】縮點"><a href="#題目-P3387-【模板】縮點" class="headerlink" title="題目: P3387 【模板】縮點"></a>題目: <a href="https://www.luogu.com.cn/problem/P3387">P3387 【模板】縮點</a></h2><p>這算是tarjan-scc(找強連通分量的tarjan算法)的練習。題目中提到，路線可以重複走，不過每個點只能被計算一次，那顯然我們可以把一個可以從A點開始走，走回A點的子圖，也就是一個強連通分量，縮成一個點。因為要讓值最大，必定是把這個子圖裡面的點都走一遍，所以這個縮出來的點，點權就是這個子圖的所有點加總。</p>
<p>接著，得到縮完點的圖之後，會發現這個圖必定是DAG(有向無環圖)。因為每個點都是由一個強連通分量而來，如果兩個強連通分量之間，有環存在的話，他們兩個就會被併成一個強連通分量。</p>
<p>知道他是DAG後，我們就可以利用拓樸排序找最長路的方法，找到圖中權值最大的路徑。</p>
<p>順帶一提，這是tarjan的教學: <a href="https://oi-wiki.org/graph/scc/">強連通分量 - OI Wiki</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; gra[MAXN]; <span class="comment">// 原圖</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; gra_new[MAXN]; <span class="comment">// 縮完點的圖</span></span><br><span class="line"><span class="type">int</span> w[MAXN]; <span class="comment">// 點權</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> DFN[MAXN];<span class="comment">// tarjan-scc的DFN</span></span><br><span class="line"><span class="type">int</span> LOW[MAXN]; <span class="comment">// tarjan-scc的LOW</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; sta; <span class="comment">// tarjan-scc的stack</span></span><br><span class="line"><span class="type">int</span> instack[MAXN]; <span class="comment">// tarjan-scc的stack的instack</span></span><br><span class="line"><span class="type">int</span> vis[MAXN]; <span class="comment">// 紀錄是tarjan否走過</span></span><br><span class="line"><span class="type">int</span> belong[MAXN]; <span class="comment">// 記錄該點屬於那個縮點</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; root; <span class="comment">// 記錄縮出來的點有哪些(編號)</span></span><br><span class="line"><span class="type">int</span> ind=<span class="number">0</span>; <span class="comment">// tarjan-scc的順序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> v)</span></span>&#123; <span class="comment">// 經典的tarjan算法</span></span><br><span class="line"></span><br><span class="line">	DFN[v] = ++ind;</span><br><span class="line">	LOW[v] = DFN[v];</span><br><span class="line">	sta.<span class="built_in">push_back</span>(v);</span><br><span class="line">	instack[v] = <span class="number">1</span>;</span><br><span class="line">	vis[v] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i:gra[v])&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(i);</span><br><span class="line">			LOW[v] = <span class="built_in">min</span>(LOW[v],LOW[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(instack[i])&#123;</span><br><span class="line">			LOW[v] = <span class="built_in">min</span>(LOW[v],DFN[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(LOW[v] == DFN[v])&#123;</span><br><span class="line">		root.<span class="built_in">push_back</span>(v);</span><br><span class="line">		<span class="type">int</span> total = <span class="number">0</span>; <span class="comment">// 這個強連通分量中合起來的點權</span></span><br><span class="line">		<span class="type">int</span> u = sta.<span class="built_in">back</span>();</span><br><span class="line">		<span class="keyword">while</span>(u!=v)&#123;</span><br><span class="line">			belong[u] = v;</span><br><span class="line">			sta.<span class="built_in">pop_back</span>();</span><br><span class="line">			instack[u] = <span class="number">0</span>;</span><br><span class="line">			total += w[u]; <span class="comment">// 加上每個點</span></span><br><span class="line">			u = sta.<span class="built_in">back</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		belong[u] = v; <span class="comment">// 該點屬於以u為根的縮點</span></span><br><span class="line">		sta.<span class="built_in">pop_back</span>();</span><br><span class="line">		instack[u] = <span class="number">0</span>;</span><br><span class="line">		total += w[u];</span><br><span class="line">		w[v] = total; <span class="comment">// 讓這個代表縮點的根，點權變成整個子圖的總量</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> vis_2[MAXN]; <span class="comment">// 紀錄DFS有沒有走過</span></span><br><span class="line"><span class="type">int</span> rd[MAXN]; <span class="comment">// 入度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> v)</span></span>&#123; <span class="comment">// 用來建立新圖的DFS</span></span><br><span class="line">	vis_2[v] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i:gra[v])&#123;</span><br><span class="line">        <span class="comment">// 如果有不同縮點的點連接，相當於這兩個縮點連接</span></span><br><span class="line">		<span class="keyword">if</span>(belong[v]!=belong[i]) </span><br><span class="line">			gra_new[ belong[v] ].<span class="built_in">push_back</span>(belong[i]), rd[belong[i]]++;</span><br><span class="line">		<span class="keyword">if</span>(!vis_2[i])&#123;</span><br><span class="line">			<span class="built_in">DFS</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[MAXN]; <span class="comment">// 拓樸最長路的DP</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">topo</span><span class="params">()</span></span>&#123; <span class="comment">// 拓樸最長路</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i:root)&#123;</span><br><span class="line">		dp[i] = w[i];</span><br><span class="line">		<span class="keyword">if</span>(rd[i]==<span class="number">0</span>) que.<span class="built_in">push</span>(i),ans = <span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u = que.<span class="built_in">front</span>();</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i:gra_new[u])&#123;</span><br><span class="line">			rd[i]--;</span><br><span class="line">			<span class="keyword">if</span>(rd[i]==<span class="number">0</span>) que.<span class="built_in">push</span>(i);</span><br><span class="line">			dp[i] = <span class="built_in">max</span>(dp[i],w[i]+dp[u]);</span><br><span class="line">			ans = <span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	cin&gt;&gt;w[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">	<span class="type">int</span> a,b;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	gra[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="comment">// 用for迴圈避免1號點走不到的地方被忽略</span></span><br><span class="line">	<span class="keyword">if</span>(!DFN[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="comment">// 用for迴圈避免1號點走不到的地方被忽略</span></span><br><span class="line">	<span class="keyword">if</span>(!vis_2[i]) <span class="built_in">DFS</span>(i);</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="built_in">topo</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 測試用測資</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">8 9</span></span><br><span class="line"><span class="comment">1 2 4 8 16 32 64 128</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">2 5</span></span><br><span class="line"><span class="comment">3 6</span></span><br><span class="line"><span class="comment">7 4</span></span><br><span class="line"><span class="comment">4 1</span></span><br><span class="line"><span class="comment">1 8</span></span><br><span class="line"><span class="comment">8 2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 輸出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">239</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>封面圖來源: <a href="https://www.pixiv.net/artworks/108016482">メイド虹夏〜！</a></p>
<hr>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>圖論</tag>
        <tag>拓樸排序</tag>
        <tag>普及+/提高</tag>
        <tag>tarjan</tag>
        <tag>最長路</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;洛谷&gt; P5020 [NOIP2018 提高組] 貨幣系統</title>
    <url>/%E6%B4%9B%E8%B0%B7/luogu-P5020/</url>
    <content><![CDATA[<h2 id="題目-P5020-NOIP2018-提高組-貨幣系統"><a href="#題目-P5020-NOIP2018-提高組-貨幣系統" class="headerlink" title="題目: P5020 [NOIP2018 提高組] 貨幣系統"></a>題目: <a href="https://www.luogu.com.cn/problem/P5020">P5020 [NOIP2018 提高組] 貨幣系統</a></h2><p>看到這種找錢問題，就是個很標準的無限背包問題，不知道的可以參考<a href="https://web.ntnu.edu.tw/~algo/KnapsackProblem.html#8">演算法筆記 Coin Change Problem</a>。</p>
<p>不過，從題目的條件中，我們找不到到底該枚舉到多少，去確認他是否可以被湊出來。</p>
<p>讓我們先回到題目來看，他希望我們在保證貨幣系統一樣的情況下，讓貨幣的種類越少越好。這時我們有兩種想法:</p>
<ol>
<li>構造一個跟原本數組完全無關的數組，不過兩者系統等價</li>
<li>把原本數組簡化，讓他的貨幣種類變少</li>
</ol>
<p>關於第一種方法，我寫的當下不知道怎麼證明，所以就直接嘗試了第二種方法。關於第一種方法的證明，可以參考<a href="https://www.luogu.com.cn/blog/0x3meow/solution-p5020">题解 P5020 【货币系统】</a></p>
<p>至於第二種方法，要把數組簡化，就是把那先不必要出現的貨幣種類刪除，也就是可以被其他貨幣湊出來的。</p>
<p>既然知道這個，那我們就可以知道套回找錢問題中，我們希望判斷是否能被湊出來的最大值，就會是現有貨幣的最大值。此題的a&lt;25000也可以讓我們在無限背包的時間複雜度下完成。</p>
<p>實作上，因為一定是用小面額去湊大面額，所以我們要先排序一遍，從最小的面額開始去湊，過程中，如果能把大面額湊出來，就把他刪掉，最後看剩下多少就是答案了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">25005</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line">cin&gt;&gt;T;</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">	<span class="type">int</span> dp[MAXN]; <span class="comment">// 是否能被湊出</span></span><br><span class="line">	<span class="type">int</span> exist[MAXN]; <span class="comment">// 這個面額是否存在</span></span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">	<span class="built_in">memset</span>(exist,<span class="number">0</span>,<span class="built_in">sizeof</span>(exist));</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> a;</span><br><span class="line">		cin&gt;&gt;a;</span><br><span class="line">		exist[a] = <span class="number">1</span>;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>()); <span class="comment">// 為了從小開始，排序</span></span><br><span class="line"></span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i:vec)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> w=i;w&lt;=(*vec.<span class="built_in">rbegin</span>());w++)&#123; <span class="comment">// 最大值為排序完的最後一項</span></span><br><span class="line">		dp[w] = dp[w] | dp[w-i];</span><br><span class="line">        <span class="comment">// 如果可以被別的面額湊出，並且存在，則刪除</span></span><br><span class="line">		<span class="keyword">if</span>(dp[w]==<span class="number">1</span> &amp;&amp; exist[w] == <span class="number">1</span> &amp;&amp; w!=i)&#123;</span><br><span class="line">			<span class="keyword">auto</span> iter = <span class="built_in">lower_bound</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),w);</span><br><span class="line">			vec.<span class="built_in">erase</span>(iter);</span><br><span class="line">			exist[w] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;vec.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>封面圖來源: <a href="https://www.pixiv.net/artworks/106379296">BoNiji(ぼ虹)</a></p>
<hr>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>普及+/提高</tag>
        <tag>DP</tag>
        <tag>背包</tag>
        <tag>無限背包</tag>
      </tags>
  </entry>
</search>
