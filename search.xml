<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>&lt;洛谷&gt; P2827 [NOIP2016 提高組] 蚯蚓</title>
    <url>/%E6%B4%9B%E8%B0%B7/luogu-P2827/</url>
    <content><![CDATA[<p>題目: <a href="https://www.luogu.com.cn/problem/P2827">P2827 [NOIP2016 提高組] 蚯蚓</a></p>
<h2 id="90分解"><a href="#90分解" class="headerlink" title="90分解:"></a>90分解:</h2><p>看到這個題目，我第一個想到的就是用<strong>priority_queue</strong>來維護，一個一個找出最長的蟲子，並做操作。</p>
<p>其中，需要處理的是，每隻蟲子會成長的問題。因為不可能把資結裡面的所有蟲子都加上成長量，因此我們換個思路。因為在資結裡的資料，重點是要比大小，因此只要能讓他的大小順序保持住就好。那我們就不對資料結構裡面的所有蟲加上成長量，反過來把新加入的蟲(切出來的)減去成長量，他們之間的相對值就能維持住。另外開一個變數來記錄總成長量，當我們需要求蟲的長度時，再把成長量加回去就可以得到值了。</p>
<p>這個方法的複雜度是$O(MlogN)$，我本來預期會過，不過出題者好像把這個複雜度卡掉了。如果壓常很強的話，搞不好可以透過這個方法AC?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line"><span class="type">int</span> n,m,q,t;</span><br><span class="line"><span class="type">double</span> u,v;</span><br><span class="line"><span class="type">double</span> p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios_base::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;q&gt;&gt;u&gt;&gt;v&gt;&gt;t;</span><br><span class="line">	<span class="type">int</span> num = n; <span class="comment">// 用來記錄目前有幾隻蟲</span></span><br><span class="line">	p = u/v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">double</span> temp;</span><br><span class="line">		cin&gt;&gt;temp;</span><br><span class="line">		pq.<span class="built_in">push</span>(temp); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> len_add = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> longest = pq.<span class="built_in">top</span>() + len_add; </span><br><span class="line">		pq.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(i%t==<span class="number">0</span>)&#123;</span><br><span class="line">			cout&lt;&lt;longest&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		num--;</span><br><span class="line">		len_add += q; <span class="comment">// 總成長量為 m*q</span></span><br><span class="line">		<span class="type">int</span> a = <span class="built_in">int</span>(longest * p);</span><br><span class="line">		<span class="type">int</span> b = longest - a;</span><br><span class="line">		pq.<span class="built_in">push</span>(a - len_add ); <span class="comment">// 減去總成長量，等於前面這一段時間的成長量都沒有吃掉</span></span><br><span class="line">		pq.<span class="built_in">push</span>(b - len_add);</span><br><span class="line">		num += <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i%t==<span class="number">0</span>)</span><br><span class="line">			cout&lt;&lt;pq.<span class="built_in">top</span>() + len_add&lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">// 因為有減去，所以拿出來的時候，加回來</span></span><br><span class="line">		pq.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="100分解"><a href="#100分解" class="headerlink" title="100分解:"></a>100分解:</h2><p>這個方法是利用單調性來維護，就可以去掉$logN$的複雜度，把剩下的十分拿下。</p>
<p>不過這是我看題解思路寫的，我自己真的沒有觀察出他有單調性。</p>
<p>首先，要觀察出一件事，<strong>先被切出來的蟲，一定比後被切出來的蟲長</strong><br>假設目前最大的兩隻蟲為$a,b$，$a&gt;b$<br>過一秒後，$a$被切成$pa,(1-p)a$，$b$成長為$b+q$<br>再過一秒，$a$的兩條蟲成長為$pa+q,(1-p)a+q$，$b$被切成$pb+pq,(1-p)b+(1-p)q$<br>因為$a&gt;b$，$0 &gt; p &gt; 1$，所以$pa+q &gt; pb+pq$，$(1-p)a+q &gt; (1-p)b+(1-p)q$<br>可以發現切出來的蟲中，較長蟲一定比後面切出的較長蟲更長，較短蟲一定比後面切出的較短蟲更長<br>接下來兩者的成長都是同時發生，所以相對大小不變<br>發現他的單調性，再把它分成另外兩堆，就可以不用priority_queue來維護了<br>找最長的蟲時，只要從這兩堆，跟原本還沒被切過的那堆(3堆)中，挑出來最大的就行了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; non_dq; <span class="comment">// 沒被切的蟲</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; dq_min; <span class="comment">// 切出來較短的蟲</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; dq_max; <span class="comment">// 切出來較長的蟲</span></span><br><span class="line"><span class="type">int</span> n,m,q,t;</span><br><span class="line"><span class="type">double</span> u,v;</span><br><span class="line"><span class="type">double</span> p;</span><br><span class="line"><span class="type">int</span> len_add = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_longest</span><span class="params">()</span></span>&#123; <span class="comment">// 從3堆中找最大值得函式，我寫的比較醜一點</span></span><br><span class="line">	<span class="type">int</span> longest;</span><br><span class="line">	<span class="keyword">if</span>(dq_max.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="keyword">if</span>(dq_min.<span class="built_in">empty</span>())</span><br><span class="line">			longest = non_dq.<span class="built_in">back</span>() + len_add,non_dq.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(non_dq.<span class="built_in">empty</span>())</span><br><span class="line">			longest = dq_min.<span class="built_in">back</span>() + len_add,dq_min.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(non_dq.<span class="built_in">back</span>() &gt;= dq_min.<span class="built_in">back</span>())</span><br><span class="line">				longest = non_dq.<span class="built_in">back</span>() + len_add,non_dq.<span class="built_in">pop_back</span>();</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				longest = dq_min.<span class="built_in">back</span>() + len_add,dq_min.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(dq_min.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="keyword">if</span>(dq_max.<span class="built_in">empty</span>())</span><br><span class="line">			longest = non_dq.<span class="built_in">back</span>() + len_add,non_dq.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(non_dq.<span class="built_in">empty</span>())</span><br><span class="line">			longest = dq_max.<span class="built_in">back</span>() + len_add,dq_max.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(non_dq.<span class="built_in">back</span>() &gt;= dq_max.<span class="built_in">back</span>())</span><br><span class="line">				longest = non_dq.<span class="built_in">back</span>() + len_add,non_dq.<span class="built_in">pop_back</span>();</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				longest = dq_max.<span class="built_in">back</span>() + len_add,dq_max.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(non_dq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="keyword">if</span>(dq_max.<span class="built_in">empty</span>())</span><br><span class="line">			longest = dq_min.<span class="built_in">back</span>() + len_add,dq_min.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(dq_min.<span class="built_in">empty</span>())</span><br><span class="line">			longest = dq_max.<span class="built_in">back</span>() + len_add,dq_max.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(dq_max.<span class="built_in">back</span>() &gt;= dq_min.<span class="built_in">back</span>())</span><br><span class="line">				longest = dq_max.<span class="built_in">back</span>() + len_add,dq_max.<span class="built_in">pop_back</span>();</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				longest = dq_min.<span class="built_in">back</span>() + len_add,dq_min.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(dq_min.<span class="built_in">back</span>() &gt;= dq_max.<span class="built_in">back</span>() &amp;&amp; dq_min.<span class="built_in">back</span>() &gt;= non_dq.<span class="built_in">back</span>())</span><br><span class="line">			longest = dq_min.<span class="built_in">back</span>() + len_add,dq_min.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(dq_max.<span class="built_in">back</span>() &gt;= dq_min.<span class="built_in">back</span>() &amp;&amp; dq_max.<span class="built_in">back</span>() &gt;= non_dq.<span class="built_in">back</span>())</span><br><span class="line">			longest = dq_max.<span class="built_in">back</span>() + len_add,dq_max.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			longest = non_dq.<span class="built_in">back</span>() + len_add,non_dq.<span class="built_in">pop_back</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios_base::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;q&gt;&gt;u&gt;&gt;v&gt;&gt;t;</span><br><span class="line">	<span class="type">int</span> num = n;</span><br><span class="line">	p = u/v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">double</span> temp;</span><br><span class="line">		cin&gt;&gt;temp;</span><br><span class="line">		non_dq.<span class="built_in">push_back</span>(temp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(non_dq.<span class="built_in">begin</span>(), non_dq.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> longest = <span class="built_in">find_longest</span>();</span><br><span class="line">		<span class="keyword">if</span>(i%t==<span class="number">0</span>)&#123;</span><br><span class="line">			cout&lt;&lt;longest&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		num--;</span><br><span class="line">		len_add += q;</span><br><span class="line">		<span class="type">int</span> a = <span class="built_in">int</span>(longest * p);</span><br><span class="line">		<span class="type">int</span> b = longest - a;</span><br><span class="line">		<span class="keyword">if</span>(a&lt;b) <span class="built_in">swap</span>(a,b); <span class="comment">// 保持a是比較長的那隻</span></span><br><span class="line">		dq_max.<span class="built_in">push_front</span>(a - len_add); <span class="comment">// 把較長的蟲，跟較短的蟲分開維護</span></span><br><span class="line">		dq_min.<span class="built_in">push_front</span>(b - len_add);</span><br><span class="line">		num += <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;i++)&#123;</span><br><span class="line">		<span class="type">int</span> longest = <span class="built_in">find_longest</span>();</span><br><span class="line">		<span class="keyword">if</span>(i%t==<span class="number">0</span>)</span><br><span class="line">			cout&lt;&lt;longest&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>封面圖來源: <a href="https://www.pixiv.net/artworks/106276835">虹夏ちゃん✨</a></p>
<hr>
]]></content>
      <categories>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>單調</tag>
        <tag>priority_queue</tag>
        <tag>提高+/省選-</tag>
      </tags>
  </entry>
</search>
